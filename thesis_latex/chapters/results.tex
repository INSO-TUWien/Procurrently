%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{Results}
\label{sec:results}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this chapter Procurrently will be evaluated based on the scenarios and compared to existing tools.
Furthermore limitations compared to other tools will be described.

\section{Evaluation}
Procurrently succeeded in using information provided by Git to provide branch based real time document synchronization. Only changes on the same branch are displayed to other users.

Changes to all documents in Git projects are shared with other peers (note that this is not the entire project structure as described in Limitations).

Changes can be staged by author. This provides accountablility and clarity about changes.

Files defined to be ignored by Git are also ignored by Procurrently.

\subsection{Other Solutions}
Procurrently runs on the client and to some extent even works offline. Although some of the Tools described in \ref{sec:stateoftheart} are client side applications/extensions none of them provide support working offline. Having data available on the client at all times provides a performance advantage for Procurrently because when changesets have to be computed for displaying/hiding remote changes or branches are switched all the necessary data is already in memory on the device and is therefore very fast. It is also enables real time collaborations in environments without a stable internet connection such as trains.

Other solutions do not consider the version control system when providing real time changes. This limits their usability in corporate environments. Procurrently is a tool for Git based environments and their use-cases in corporate environments. 

\subsection{Testing Procurrently in the Real World}

Procurrently was tested in a real world development environment with 2 users for 5 hours. After a short introduction to the new Git checkout procedure the tool did not cause friction for the users. During the test situations similar to \ref{sec:scenario1} were encountered multiple times. Procurrently was working as expected and aided the problem solution by providing fast context switching without the overhead of synchronizing changes via Git.

\section{Limitations}

Compared to other current solutions, Procurrently is unable to track files that do not exist in the last Git commit because the base version of a file is derived from the lastest Git commit. This behaviour is necessary because some VS Code extensions create temporary files that do not get persisted to the filesystem but fire change events.

Procurrently is not secure. Anyone on the network can modify files in the repository. Also all the traffic is unencrypted and can therefore be read by anyone on the network.

The staging view does not differentiate between different branches so all collaborators across all Git repositories and branches are presented as stageable instead of filtering by collaborators who changed the current working context.

Due to the possible inconsistencies introduced by the asynchronous VS Code applyEdit API function and the workaround described in \ref{subsec:concurrentchanges} processing huge change sets is noticeably slow. This is most obvious when processing multi cursor changes with more than 20 cursors at once.
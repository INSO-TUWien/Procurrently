\chapter{Implementation}

\section{Git}

Git provides useful information about the current project, the developer is working on, such as:
\begin{itemize}
    \item The current branch (the problem being worked on)
    \item The root directory of the project (for path resolution across devices)
    \item The current version of a file (as a basis for collaborative edits)
    \item Information about the developer (the username)
\end{itemize}

Git stores this information in the ".git" directory in the root folder of the project.
The data is stored in a compressed format. In order to access the information, a small library using low level git commands was implemented. 

It provides functions to:
\begin{itemize}
    \item Find the Git directory for a given file (given the file is inside a git project)
    \item Get the current branch of a Git repository
    \item Get the remote URL for a repository
    \item Get the current version of a given file
    \item Stage a file for commit
    \item Get the username configured for the Git repository
    \item Get a list of branches of a Git repository
    \item Switch a repository to a different branch
\end{itemize}

\section{teletype-crdt}

"The string-wise sequence CRDT powering peer-to-peer collaborative editing in Teletype for Atom."\footnote{https://github.com/atom/teletype-crdt}
This library will be used for tracking changes. It is written in JavaScript and currently doesn't include an API documentation.

The main functions used are

\begin{lstlisting}
setTextInRange(start: {row:Number, column:Number}, end: {row:Number, column:Number}, text: string, options?: any): [operation];
\end{lstlisting}
which is used to notify the document representation about a text operation on the local document and
\begin{lstlisting}
integrateOperations(operations: [operations]): {textUpdates:[textUpdate], markerUpdates:any};
\end{lstlisting}
which is used to notify the document representation about remote changes and returns the changes to the local file required to keep it in sync with other instances
and
\begin{lstlisting}
undoOrRedoOperations(operationsToUndo: [operation]): any;
\end{lstlisting}
which is used to undo changes.

\subsection{Git and teletype-crdt}
As a basis for the edit history  the current Git commit in the current branch will be used. teletype-crdt uses numeric siteIds to identify changes by author. The current Git commit is imported as edited by siteId 1 upon discovering the file. By doing this, all clients have an initial shared state based on the current version of the file known to Git.

\section{VS Code Extension API}

VS Code runs extension in a seperate process and provides an asynchronous Javascript API.
The examples provided in the vscode-extension-samples repository\footnote{https://github.com/Microsoft/vscode-extension-samples} are mostly written in Typescript\footnote{https://www.typescriptlang.org/} and all the Interfaces have type definitions for Typescript.
Therefore the Extension will use Typescript as well.

\subsection{Used API functions}

\begin{lstlisting}
vscode.workspace.onDidChangeTextDocument()
\end{lstlisting}

"An event that is emitted when a text document is changed. This usually happens when the contents changes but also when other things like the dirty-state changes."\footnote{https://code.visualstudio.com/api/references/vscode-api\#workspace}

\begin{lstlisting}
vscode.workspace.onDidOpenTextDocument()
\end{lstlisting}

"An event that is emitted when a text document is opened or when the language id of a text document has been changed."\footnote{https://code.visualstudio.com/api/references/vscode-api\#workspace}

\begin{lstlisting}
vscode.workspace.applyEdit(edit)
\end{lstlisting}
"Make changes to one or many resources or create, delete, and rename resources as defined by the given workspace edit."\footnote{https://code.visualstudio.com/api/references/vscode-api\#workspace}

This function returns a promise which resolves when the change has been added to the text document.
An edit is given by a document, the line and column of start and end of the edit in that document and the new text to be inserted there.
If text is added or removed within a line, the columns of the text change after the edit has been applied (when the promise resolves). If another edit is applied before the promise resolved, the indices of the text might have not been changed yet and therefore at a different position than expected. VS Codes WorkspaceEdit supports grouping change operations together. But change operations are not treated as happening all at a time so if for example the text "123" was typed the teletype-crdt library would essentially output Line 1 Char 1 to Line 1 Char 1 changed to "1", Line 1 Char 2 to Line 2 Char 2 changed to "2" and so on. This is kind of expected behaviour so far but VS Code's WorkspaceEdit treats this as independent operations and if there was text after the insertion the changes would not be inserted as 1 block but interlaced with the previous text. 

In order to avoid this race condition all changes to a file have to be carried out sequentially. This is not noticable when changes by regular typing are integrated into the local document. But when the multiple cursors\footnote{https://code.visualstudio.com/docs/getstarted/tips-and-tricks\#\_editing-hacks} are used the change integration can slow down noticably. In order to support multiple cursors the changes are sorted by column in decending order to prevent shifting indices. 
\begin{lstlisting}
textUpdates.sort((a, b) => b.oldStart.column - a.oldStart.column)
\end{lstlisting}

\subsection{Tree View}

In order to stage changes by author, a treeview listing the Authors, who made changes, was created.
The container for a treeview needs to be defined in the package.json file. 

\begin{figure}[]
    \centering
    \includegraphics{figures/screenshots/treeview.png}
    \caption{Tree view}
    \label{fig:treeview}
\end{figure}

\begin{lstlisting}[label={lst:contributes_treeview_activitybar}]
"contributes": {
    "viewsContainers": {
        "activitybar": [
            {
                "id": "change-explorer",
                "title": "Change Explorer",
                "icon": "media/icon.svg"
            }
        ]
    }
    [...]
}
\end{lstlisting}

First an entry in the activity bar has to be declared in the viewsContainers section \ref{lst:contributes_treeview_activitybar}. It defines the icon as well as the hover text (called title) of the tab in the activity bar.

\begin{lstlisting}[label={lst:contributes_treeview_view}]
"contributes": {
    [...]
    "views": {
        "change-explorer": [
            {
                "id": "contributors",
                "name": "Contributors"
            }
        ]
    }
}
\end{lstlisting}

Additionally the view has to be declared.\ref{lst:contributes_treeview_view} This defines the heading for the treeview.

\begin{lstlisting}[label={lst:contributes_treeview_register} caption=Define Tree View Data Provider]
const treeview = new ContributorsTreeView(crdt.getUsers);
vscode.window.registerTreeDataProvider('contributors', treeview);
\end{lstlisting}

To populate the Tree View with data, a TreeDataProvider has to be registered to the view id.\ref{lst:contributes_treeview_register}
The TreeDataProvider interface defines functions that return all items for the treeview as well as refresh the content of the treeview.

\section{Data Model}

\begin{lstlisting}[label={lst:datamodel_declarations}, caption=data model declarations]
const documents = new Map<string, { document: Document, metaData: { commit: string, branch: string, repo: string, file: string, users: Map<Number, string> } }>();
/** remote repository to path mapping */
const localPaths = new Map<string, string>();
/** The current branch for a file */
const branches = new Map<string, string>();
\end{lstlisting}

All the data is stored in a map called documents.(See \ref{lst:datamodel_declarations})
It's key is composed of the filename and a specifier composed from the commit, branch and remote/origin repository URL.

In order to keep track of the current branch and head commit of files, the branches map contains the identifier for a file by filepath.

The localPaths map contains mappings from remote/origin urls to local git directory locations.
This enables keeping track of files across different projects.


The documents map values contain

\subsection{The Document Object}

The document object has two properties

\begin{itemize}
    \item document
    \item metaData
\end{itemize}

The document property points to an instalce of the document class provided by teletype-crdt.

The metaData property contains the relevant information from Git about the document:
\begin{itemize}
    \item branch
    \item commit
    \item repo
    \item file
    \item users
\end{itemize}

The users property contains a map with the teletype-crdt siteId as a key and the git username as a value.
This information is required to display usersnames in the staging Tree View.

\section{Reacting to Local Changes}

In order to process a local change, provided by the onDidChangeTextDocument API call, the extension first checks, if the change has been added by a remote client. This is necessary because the VS Code API does not differentiate between changes by the user and changes by extensions. (See \ref{lst:localchange_check_known}) Otherwise changes are duplicated endlessly because every remote change is propagated back to all other clients as a new change.

\begin{lstlisting}[label={lst:localchange_check_known}, caption=Is this change already known to the data model? ]
const objects = ['start', 'end'];
const props = ['line', 'character'];

//check if this change has just been added by remote
const knownChanges = currentChanges
    .filter(c => 
        objects.map(o => 
            props.map(p => 
                c[o][p] == change.range[o][p])) 
        && c.text == change.text 
        && c.filename == e.document.fileName);
if (knownChanges.length > 0) {
    //remove from known changes
    currentChanges.splice(currentChanges.indexOf(knownChanges[0]));
}
\end{lstlisting}

To update the teletype-crdt document the setTextInRange function is used. It returns a list of operations. This list of operations is sent in a JSON object containing the metaData associated with the document.\ref{lst:change_json}

\begin{lstlisting}[label={lst:change_json}, caption=Network Data Packet]
{
    "update": {
        "metaData": {
            "branch": "refs/heads/master",
            "commit": "05fc4663235f36ba054ea37fd7f92e9a5555edf2",
            "repo": "git@bitbucket.org:company/a_repository.git\n",
            "file": "/app.js",
            "users": {}
        },
        "operations": [
            {
                "type": "splice",
                "spliceId": {
                    "site": 2766400253437581,
                    "seq": 3
                },
                "insertion": {
                    "text": "a",
                    "leftDependencyId": {
                        "site": 0,
                        "seq": 0
                    },
                    "offsetInLeftDependency": {
                        "row": 0,
                        "column": 0
                    },
                    "rightDependencyId": {
                        "site": 2766400253437581,
                        "seq": 1
                    },
                    "offsetInRightDependency": {
                        "row": 0,
                        "column": 0
                    }
                }
            }
        ],
        "authors": [
            [
                2766400253437581,
                "Stefan Gussner"
            ]
        ]
    }
}
\end{lstlisting}

\section{Network Transport}

\subsection{Establishing the Peer To Peer Connections}
On Bootup a connection to a bootstrap server is established. 
The peer sends the bootstrap server his ip as well as the port of the socket the peer is listening on for incoming connections.
Upon recieving this information the bootstrap server responds with a list of ips and ports of all the other registered peers.
The peer then tries to connect to every peer in that list.

Once a connection is established, the peers exchange all the operations they know about.

\subsection{Handling Changes}
Every change is propergated to every node known to the peer. This approach only works for small groups. To scale up to more clients, peers could intelligently only send changes to peers, who are currently on the same branch and peers could request operations from other clients when switching branches. Additionally changes could be propergated via a gossip based protocol.

\section{Handling Remote Changes}

Handling incoming changes has two main challanges:
\begin{itemize}
    \item concurrent changes
    \item finding files on disk
\end{itemize}

\subsection{Concurrent Changes}

Concurrent changes can introduce errors when adding them to a file. 
Given two changes on the same line one of the changes will have it's index changed by the other one.

To illustrate the problem consider this example:

The initial line consists of the string "12345".
Now peer A adds "g" after index 3 and peer B adds "c" after index 4
The local result for A is "123g45" and the local result for B is "1234c5".
The correct result for the changes would then be "123g4c5"
The crdt data type handles this concurrency problem and if the change from peer B is processed after the change from peer A the insert operation of B is adjusted from index 4 to 5.
But this assumes that all the changes are processed sequentially. If the order of insertions is not guaranteed the resulting string could turn into "123g45c" if the crdt document processes the changes in the order A -> B and the VS Code Edit is processed in the order B -> A.

In order to deal with this problem the network waits for the promise chain handling the response until the change has been added to the file.

\begin{lstlisting}[label={lst:promise_chain}, caption=Network Promise Chain]
this._currentEdit = this._currentEdit.then(() => {
    [...]
    return this._onremoteEdit(recieved.update);
    [...]
})
\end{lstlisting}

\ref{lst:promise_chain} ensures that incoming change packets are processed sequentially by building a promise chain.

\subsection{Finding files on Disk}

Given the information from the network finding the file the change corresponds to is not trivial.

First the appropriate Git repository has to be located.
